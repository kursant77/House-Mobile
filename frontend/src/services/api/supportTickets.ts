import { supabase } from "@/lib/supabase";

export interface SupportTicket {
    id: string;
    ticket_number: string;
    user_id: string;
    issue_title: string;
    issue_description: string;
    priority: 'low' | 'medium' | 'high' | 'urgent';
    status: 'open' | 'pending' | 'resolved' | 'closed';
    assigned_to?: string;
    created_at: string;
    updated_at: string;
    resolved_at?: string;
    user?: {
        full_name: string;
        email: string;
        avatar_url?: string;
    };
}

export const supportTicketsApi = {
    // Get all tickets
    async getTickets(statusFilter?: 'all' | SupportTicket['status']) {
        let query = supabase
            .from('support_tickets')
            .select(`
        *,
        user:user_id(full_name, email, avatar_url)
      `)
            .order('created_at', { ascending: false });

        if (statusFilter && statusFilter !== 'all') {
            query = query.eq('status', statusFilter);
        }

        const { data, error } = await query;
        if (error) throw error;
        return data as SupportTicket[];
    },

    // Create ticket (for admin or user)
    async createTicket(ticket: {
        user_id: string;
        issue_title: string;
        issue_description: string;
        priority?: SupportTicket['priority'];
    }) {
        const { data, error } = await supabase
            .from('support_tickets')
            .insert({
                ...ticket,
                ticket_number: '', // Will be auto-generated by trigger
                priority: ticket.priority || 'medium',
                status: 'open'
            })
            .select(`
        *,
        user:user_id(full_name, email, avatar_url)
      `)
            .single();

        if (error) throw error;
        return data;
    },

    // Update ticket status
    async updateStatus(ticketId: string, status: SupportTicket['status']) {
        const updates: { status: SupportTicket['status']; resolved_at?: string } = { status };

        if (status === 'resolved' || status === 'closed') {
            updates.resolved_at = new Date().toISOString();
        }

        const { data, error } = await supabase
            .from('support_tickets')
            .update(updates)
            .eq('id', ticketId)
            .select()
            .single();

        if (error) throw error;
        return data;
    },

    // Update ticket priority
    async updatePriority(ticketId: string, priority: SupportTicket['priority']) {
        const { data, error } = await supabase
            .from('support_tickets')
            .update({ priority })
            .eq('id', ticketId)
            .select()
            .single();

        if (error) throw error;
        return data;
    },

    // Assign ticket to admin
    async assignTicket(ticketId: string, adminId: string) {
        const { data, error } = await supabase
            .from('support_tickets')
            .update({ assigned_to: adminId })
            .eq('id', ticketId)
            .select()
            .single();

        if (error) throw error;
        return data;
    },

    // Delete ticket
    async deleteTicket(ticketId: string) {
        const { error } = await supabase
            .from('support_tickets')
            .delete()
            .eq('id', ticketId);

        if (error) throw error;
    },

    // Get ticket stats
    async getStats() {
        const { count: total } = await supabase
            .from('support_tickets')
            .select('*', { count: 'exact', head: true });

        const { count: open } = await supabase
            .from('support_tickets')
            .select('*', { count: 'exact', head: true })
            .eq('status', 'open');

        const { count: pending } = await supabase
            .from('support_tickets')
            .select('*', { count: 'exact', head: true })
            .eq('status', 'pending');

        const { count: resolved } = await supabase
            .from('support_tickets')
            .select('*', { count: 'exact', head: true })
            .in('status', ['resolved', 'closed']);

        return {
            total: total || 0,
            open: open || 0,
            pending: pending || 0,
            resolved: resolved || 0
        };
    }
};
